# let 和 const 
通过 var 声明的变量存在变量提升的特性;

为了加强对变量生命周期的控制，ECMAScript 6 引入了块级作用域。

块级作用域存在于：
    1. 函数内部
    2. 块中(字符 { 和 } 之间的区域)

块级声明用于声明在指定块的作用域之外无法访问的变量。

let 和 const 的特点:  let 不提升，不能重复声明，不能绑定全局作用域
    1.不会被提升
    2.重复声明报错
    3.不绑定全局作用域

再来说下 let 和 const 的区别：
    const 用于声明常量，其值一旦被设定不能再被修改，否则会报错。
    值得一提的是：const 声明不允许修改绑定，但允许修改值。这意味着当用 const 声明对象时：

- 临时死区(Temporal Dead Zone)，简写为 TDZ。
    let 和 const 声明的变量不会被提升到作用域顶部，如果在声明之前访问这些变量，会导致报错
这是因为 JavaScript 引擎在扫描代码发现变量声明时，要么将它们提升到作用域顶部(遇到 var 声明)，要么将声明放在 TDZ 中(遇到 let 和 const 声明)。访问 TDZ 中的变量会触发运行时错误。只有执行过变量声明语句后，变量才会从 TDZ 中移出，然后方可访问。

- 循环中的块级作用域
    简单的来说，就是在 for (let i = 0; i < 3; i++) 中，即圆括号之内建立一个隐藏的作用域
    然后每次迭代循环时都创建一个新变量，并以之前迭代中同名变量的值将其初始化
    当执行函数的时候，根据词法作用域就可以找到正确的值，其实你也可以理解为 let 声明模仿了闭包的做法来简化循环过程。
- 循环中的 let 和 const
    如果我们把 let 改成 const,结果会是报错，因为虽然我们每次都创建了一个新的变量，然而我们却在迭代中尝试修改 const 的值，所以最终会报错。
    在 for in 循环中，每次迭代不会修改已有的绑定，而是会创建一个新的绑定
- Babel
    本质是一样的，就是改变量名，使内外层的变量名称不一样。
    那像 const 的修改值时报错，以及重复声明报错怎么实现的呢？
    其实就是在编译的时候直接给你报错……

    那循环中的 let 声明呢？
var funcs = [];
for (let i = 0; i < 10; i++) {
    funcs[i] = function () {
        console.log(i);
    };
}
funcs[0](); // 0

var funcs = [];
var _loop = function _loop(i) {
    funcs[i] = function () {
        console.log(i);
    };
};

for (var i = 0; i < 10; i++) {
    _loop(i);
}
funcs[0](); // 0

默认使用 const，只有当确实需要改变变量的值的时候才使用 let
